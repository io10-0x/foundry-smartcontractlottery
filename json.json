{"language":"Solidity","sources":{"src/Raffle.sol":{"content":"// SPDX-License-Identifier: MIT\n//Raffle\n//Enter lottery\n//Pick a random winner (verifiably random)\n//Winner to be selected every X minutes (completely automate)\n//Chainlink Oracle => Randomness, Automated Execution (Chainlink Keepers)\n\npragma solidity ^0.8.6;\n\nimport {ConfirmedOwner} from \"@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol\";\nimport {VRFV2WrapperConsumerBase} from \"@chainlink/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol\";\nimport {LinkTokenInterface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol\";\nimport {AutomationCompatibleInterface} from \"@chainlink/contracts/src/v0.8/automation/interfaces/AutomationCompatibleInterface.sol\";\n\n/**\n * @title A sample Raffle Contract\n * @author Ivan Otono\n * @notice This contract allows users to enter a raffle and be able to win ETH\n * @dev This implements Chainlink VRF and Chainlink Automation\n */\n\ncontract Raffle is\n    VRFV2WrapperConsumerBase,\n    ConfirmedOwner,\n    AutomationCompatibleInterface\n{\n    enum s_lotterystate {\n        open,\n        calculating_winner\n    }\n    s_lotterystate private s_currentlotterystate;\n    uint256 private immutable i_entrancefee;\n    uint256 private constant INTERVAL = 30;\n    address payable[] private s_players;\n    uint256 private s_lastTimeStamp;\n    event Lotteryenter(address indexed playeraddress);\n    address payable private s_recentwinner;\n    event RequestSent(uint256 indexed requestId, uint32 numWords);\n    event RequestFulfilled(\n        uint256 requestId,\n        uint256[] randomWords,\n        uint256 payment\n    );\n    event WinnerPicked(address payable indexed winner);\n\n    struct RequestStatus {\n        uint256 paid; // amount paid in link\n        bool fulfilled; // whether the request has been successfully fulfilled\n        uint256[] randomWords;\n    }\n    mapping(uint256 => RequestStatus)\n        public s_requests; /* requestId --> requestStatus */\n\n    // past requests Id.\n    uint256[] public requestIds;\n    uint256 public lastRequestId;\n\n    // Depends on the number of requested values that you want sent to the\n    // fulfillRandomWords() function. Test and adjust\n    // this limit based on the network that you select, the size of the request,\n    // and the processing of the callback request in the fulfillRandomWords()\n    // function.\n    uint32 private constant CALLBACKGASLIMIT = 500000;\n\n    // The default is 3, but you can set this higher.\n    uint16 private constant REQUESTCONFIRMATIONS = 3;\n\n    // For this example, retrieve 2 random values in one request.\n    // Cannot exceed VRFV2Wrapper.getConfig().maxNumWords.\n    uint32 private constant NUMWORDS = 1;\n\n    error Raffle__NotEnoughETH();\n    error Raffle__TransferFailed();\n    error Raffle__LotteryNotOpen();\n    error Raffle__UpkeepNotNeeded();\n\n    constructor(\n        uint256 entrancefee,\n        address linktokenaddress,\n        address v2WrapperAddress\n    )\n        ConfirmedOwner(msg.sender)\n        VRFV2WrapperConsumerBase(linktokenaddress, v2WrapperAddress)\n    {\n        i_entrancefee = entrancefee;\n        s_currentlotterystate = s_lotterystate.open;\n        s_lastTimeStamp = block.timestamp;\n    }\n\n    function enterlottery() public payable {\n        if (msg.value < i_entrancefee) {\n            revert Raffle__NotEnoughETH();\n        }\n        if (s_currentlotterystate != s_lotterystate.open) {\n            revert Raffle__LotteryNotOpen();\n        }\n\n        s_players.push(payable(msg.sender));\n        emit Lotteryenter(msg.sender);\n    }\n\n    function checkUpkeep(\n        bytes calldata checkData\n    )\n        public\n        view\n        override\n        returns (bool upkeepNeeded, bytes memory /*performData*/)\n    {\n        if (\n            (s_currentlotterystate == s_lotterystate.open) &&\n            ((block.timestamp - s_lastTimeStamp) > INTERVAL) &&\n            (address(this).balance > 0) &&\n            (s_players.length > 0)\n        ) {\n            return (true, checkData);\n        } else {\n            return (false, checkData);\n        }\n    }\n\n    function performUpkeep(bytes calldata performData) external override {\n        (bool upkeepNeeded, ) = checkUpkeep(performData);\n        if (!upkeepNeeded) {\n            revert Raffle__UpkeepNotNeeded();\n        }\n        uint256 requestId = requestRandomness(\n            CALLBACKGASLIMIT,\n            REQUESTCONFIRMATIONS,\n            NUMWORDS\n        );\n        s_requests[requestId] = RequestStatus({\n            paid: VRF_V2_WRAPPER.calculateRequestPrice(CALLBACKGASLIMIT),\n            randomWords: new uint256[](0),\n            fulfilled: false\n        });\n        s_currentlotterystate = s_lotterystate.calculating_winner;\n        requestIds.push(requestId);\n        lastRequestId = requestId;\n        emit RequestSent(requestId, NUMWORDS);\n    }\n\n    function fulfillRandomWords(\n        uint256 _requestId,\n        uint256[] memory _randomWords\n    ) internal override {\n        require(s_requests[_requestId].paid > 0, \"request not found\");\n        s_requests[_requestId].fulfilled = true;\n        s_requests[_requestId].randomWords = _randomWords;\n        emit RequestFulfilled(\n            _requestId,\n            _randomWords,\n            s_requests[_requestId].paid\n        );\n        uint256 randomNumber = _randomWords[0] % s_players.length;\n        address payable winningaddress = s_players[randomNumber];\n        s_recentwinner = winningaddress;\n\n        (bool success, ) = winningaddress.call{value: address(this).balance}(\n            \"\"\n        );\n        if (!success) {\n            revert Raffle__TransferFailed();\n        }\n        s_players = new address payable[](0);\n        emit WinnerPicked(winningaddress);\n        s_currentlotterystate = s_lotterystate.open;\n        s_lastTimeStamp = block.timestamp;\n    }\n\n    function getentrancefee() public view returns (uint256) {\n        return i_entrancefee;\n    }\n\n    function getlatestblocktimestamp() public view returns (uint256) {\n        return s_lastTimeStamp;\n    }\n\n    function getlotterystate() public view returns (s_lotterystate) {\n        return s_currentlotterystate;\n    }\n\n    function getnumplayers() public view returns (uint256) {\n        return s_players.length;\n    }\n\n    function getplayer(uint256 index) public view returns (address) {\n        return s_players[index];\n    }\n\n    function getwinner() public view returns (address payable) {\n        return s_recentwinner;\n    }\n\n    function getNumWords() public pure returns (uint256 numwords) {\n        return NUMWORDS;\n    }\n\n    function getcallbackgaslimit() public pure returns (uint256 gaslimit) {\n        return CALLBACKGASLIMIT;\n    }\n\n    function getinterval() public pure returns (uint256 interval) {\n        return INTERVAL;\n    }\n}\n"},"lib/chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwnerWithProposal} from \"./ConfirmedOwnerWithProposal.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"},"lib/chainlink/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {LinkTokenInterface} from \"../shared/interfaces/LinkTokenInterface.sol\";\nimport {VRFV2WrapperInterface} from \"./interfaces/VRFV2WrapperInterface.sol\";\n\n/** *******************************************************************************\n * @notice Interface for contracts using VRF randomness through the VRF V2 wrapper\n * ********************************************************************************\n * @dev PURPOSE\n *\n * @dev Create VRF V2 requests without the need for subscription management. Rather than creating\n * @dev and funding a VRF V2 subscription, a user can use this wrapper to create one off requests,\n * @dev paying up front rather than at fulfillment.\n *\n * @dev Since the price is determined using the gas price of the request transaction rather than\n * @dev the fulfillment transaction, the wrapper charges an additional premium on callback gas\n * @dev usage, in addition to some extra overhead costs associated with the VRFV2Wrapper contract.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFV2WrapperConsumerBase. The consumer must be funded\n * @dev with enough LINK to make the request, otherwise requests will revert. To request randomness,\n * @dev call the 'requestRandomness' function with the desired VRF parameters. This function handles\n * @dev paying for the request based on the current pricing.\n *\n * @dev Consumers must implement the fullfillRandomWords function, which will be called during\n * @dev fulfillment with the randomness result.\n */\nabstract contract VRFV2WrapperConsumerBase {\n  // solhint-disable-next-line chainlink-solidity/prefix-immutable-variables-with-i\n  LinkTokenInterface internal immutable LINK;\n  // solhint-disable-next-line chainlink-solidity/prefix-immutable-variables-with-i\n  VRFV2WrapperInterface internal immutable VRF_V2_WRAPPER;\n\n  /**\n   * @param _link is the address of LinkToken\n   * @param _vrfV2Wrapper is the address of the VRFV2Wrapper contract\n   */\n  constructor(address _link, address _vrfV2Wrapper) {\n    LINK = LinkTokenInterface(_link);\n    VRF_V2_WRAPPER = VRFV2WrapperInterface(_vrfV2Wrapper);\n  }\n\n  /**\n   * @dev Requests randomness from the VRF V2 wrapper.\n   *\n   * @param _callbackGasLimit is the gas limit that should be used when calling the consumer's\n   *        fulfillRandomWords function.\n   * @param _requestConfirmations is the number of confirmations to wait before fulfilling the\n   *        request. A higher number of confirmations increases security by reducing the likelihood\n   *        that a chain re-org changes a published randomness outcome.\n   * @param _numWords is the number of random words to request.\n   *\n   * @return requestId is the VRF V2 request ID of the newly created randomness request.\n   */\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\n  function requestRandomness(\n    uint32 _callbackGasLimit,\n    uint16 _requestConfirmations,\n    uint32 _numWords\n  ) internal returns (uint256 requestId) {\n    LINK.transferAndCall(\n      address(VRF_V2_WRAPPER),\n      VRF_V2_WRAPPER.calculateRequestPrice(_callbackGasLimit),\n      abi.encode(_callbackGasLimit, _requestConfirmations, _numWords)\n    );\n    return VRF_V2_WRAPPER.lastRequestId();\n  }\n\n  /**\n   * @notice fulfillRandomWords handles the VRF V2 wrapper response. The consuming contract must\n   * @notice implement it.\n   *\n   * @param _requestId is the VRF V2 request ID.\n   * @param _randomWords is the randomness result.\n   */\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\n  function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal virtual;\n\n  function rawFulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) external {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == address(VRF_V2_WRAPPER), \"only VRF V2 wrapper can fulfill\");\n    fulfillRandomWords(_requestId, _randomWords);\n  }\n}\n"},"lib/chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n"},"lib/chainlink/contracts/src/v0.8/automation/interfaces/AutomationCompatibleInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"},"lib/chainlink/contracts/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IOwnable} from \"../interfaces/IOwnable.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwnerWithProposal is IOwnable {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    // solhint-disable-next-line gas-custom-errors\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /// @notice Allows an owner to begin transferring ownership to a new address.\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /// @notice Allows an ownership transfer to be completed by the recipient.\n  function acceptOwnership() external override {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /// @notice Get the current owner\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /// @notice validate, transfer ownership, and emit relevant events\n  function _transferOwnership(address to) private {\n    // solhint-disable-next-line gas-custom-errors\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /// @notice validate access\n  function _validateOwnership() internal view {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /// @notice Reverts if called by anyone other than the contract owner.\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"},"lib/chainlink/contracts/src/v0.8/vrf/interfaces/VRFV2WrapperInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface VRFV2WrapperInterface {\n  /**\n   * @return the request ID of the most recent VRF V2 request made by this wrapper. This should only\n   * be relied option within the same transaction that the request was made.\n   */\n  function lastRequestId() external view returns (uint256);\n\n  /**\n   * @notice Calculates the price of a VRF request with the given callbackGasLimit at the current\n   * @notice block.\n   *\n   * @dev This function relies on the transaction gas price which is not automatically set during\n   * @dev simulation. To estimate the price at a specific gas price, use the estimatePrice function.\n   *\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\n   */\n  function calculateRequestPrice(uint32 _callbackGasLimit) external view returns (uint256);\n\n  /**\n   * @notice Estimates the price of a VRF request with a specific gas limit and gas price.\n   *\n   * @dev This is a convenience function that can be called in simulation to better understand\n   * @dev pricing.\n   *\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\n   * @param _requestGasPriceWei is the gas price in wei used for the estimation.\n   */\n  function estimateRequestPrice(uint32 _callbackGasLimit, uint256 _requestGasPriceWei) external view returns (uint256);\n}\n"},"lib/chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnable {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"}},"settings":{"remappings":["@chainlink/=lib/chainlink/","chainlink/=lib/chainlink/","forge-std/=lib/forge-std/src/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs"},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"berlin","viaIR":false,"libraries":{}}}
